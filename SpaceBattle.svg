<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <title>Space Battle</title>
  <script type="text/ecmascript"><![CDATA[
  
var svgNS = "http://www.w3.org/2000/svg";
var GameOver = true;
var CountdownTimer = 25;
var EnemyCount = 0;
var Level = 0;
var GameObjects = new Array();
var DeadObjects = new Array();
var PlayerObjects = new Array();
var CommandObjects = new Array();
var CommandRequestObjects = new Array();
var FrameCounter = 0;
var FramesPerSecond = 0;
var ZoomLevel = 800;
var GameSpeed = .66;
var CapacitorMax = 25;
var CapacitorInput = .16;
var MissileVelocity = 5;
var ExplosionSize = 20;
var MissileFuel = 100;
var tick = 0;

var singlePlayer = false;
var commandDelay = 1;

var gameObjectId = 0;
var availableHeight = window.innerHeight - 22;
var availableWidth = window.innerWidth - 22;
    
if (availableHeight < availableWidth)
{
  AvailablePixels = availableHeight;
}
else
{
  AvailablePixels = availableWidth;
}

var componentOffset = AvailablePixels * .01
var CurrentScale = AvailablePixels / ZoomLevel;
var StartingDistanceFromCenter = 100;
var roundingConstant = AvailablePixels * .02;

document.documentElement.addEventListener("keydown", KeyPress, false);

/** Initialization code. 
 * If you use your own event management code, change it as required.
 */
if (window.addEventListener)
        /** DOMMouseScroll is for mozilla. */
        window.addEventListener('DOMMouseScroll', wheel, false);
/** IE/Opera. */
window.onmousewheel = document.onmousewheel = wheel;

function Init()
{
  // Resize the canvas
  var CanvasElement = document.getElementById("Canvas");
  CanvasElement.setAttributeNS(null, "height", availableHeight);	
  CanvasElement.setAttributeNS(null, "width", availableWidth);

  // Render the ConsoleGroup
  var ConsoleGroupElement = document.createElementNS(svgNS,"g");
  verticalMargins = (availableWidth - AvailablePixels) / 2;
  horizontalMargins = (availableHeight - AvailablePixels) / 2;
  ConsoleGroupElement.setAttribute('transform', 'translate('+verticalMargins+','+horizontalMargins+')');
  CanvasElement.appendChild(ConsoleGroupElement);

  // Render the Console
  var ShipConsoleElement = document.createElementNS(svgNS,"rect");
  ShipConsoleElement.setAttributeNS(null, "x", 0);	
  ShipConsoleElement.setAttributeNS(null, "y", 0);
  ShipConsoleElement.setAttributeNS(null, "rx", roundingConstant);
  ShipConsoleElement.setAttributeNS(null, "ry", roundingConstant);
  ShipConsoleElement.setAttributeNS(null, "height", AvailablePixels);	
  ShipConsoleElement.setAttributeNS(null, "width", AvailablePixels);
  ShipConsoleElement.setAttributeNS(null, "fill", 'gray');
  ConsoleGroupElement.appendChild(ShipConsoleElement);

  // Render the Console Components
  renderScope(ConsoleGroupElement);
  renderRibbon(ConsoleGroupElement);
  renderMissionSummary(ConsoleGroupElement);
  renderCapacitor(ConsoleGroupElement);
  renderDebugger(ConsoleGroupElement);
  renderAutoPilot(ConsoleGroupElement);
  renderFireButton(ConsoleGroupElement);
}

function NewGame()
{
  ClearGameObjects()
  PlayerObjects.length = 0;
  CommandObjects.length = 0;
  CommandRequestObjects.length = 0;
    
  GameOver = false;
  CountdownTimer = 25;
  Level = Level + 1;
  EnemyCount = Level;
  gameObjectId = 0;
  
  GameObjects.length = 0;
  
  CreateShipObject('Human', 0);

  for (var i=0, j=Level; i<j; i++)
  {
    CreateShipObject('Computer', i);
  }

  FrameCounter = 0;

  Timer = setInterval("UpdateFramesPerSecond()", 1000);
  GameLoopInterval = setInterval("GameLoop()", 40);
}

function ClearGameObjects()
{
  for (var i=0, j=GameObjects.length; i<j; i++)
  {
    DeadObjects.push(GameObjects[i]);
  }
  
  RemoveDeadObjects();
}

function CreateShipObject(ShipType, ComputerShipNumber)
{
  if (ShipType == 'Human')
  {
    // I'm making the human ship pointer global so that I can easily get it's coordinates for updating the map perspective.
    HumanShip = new GameObject(gameObjectId, 'HumanShip', 0, 0, 0, 0, 0, 'hidden', 5, 'None', 0, 1000, 10);
    var HumanPlayer = new PlayerObject(-1, gameObjectId)
    GameObjects.push(HumanShip);
    PlayerObjects.push(HumanPlayer);
    // SetStartingPosition(HumanShip, 180); // If I don't set the start position of the ship, it should get set to the very center
    CreateShipElement(HumanShip);
    UpdateShipElement(HumanShip);
  }
  else
  {
    var NewComputerShip = new GameObject(gameObjectId, 'ComputerShip', 0, 0, 0, 0, 0, 'hidden', 5, 'None', 0, 1000, 10);
    var ComputerPlayer = new PlayerObject(ComputerShipNumber, gameObjectId)
    GameObjects.push(NewComputerShip);
    PlayerObjects.push(ComputerPlayer);
    SetStartingPosition(NewComputerShip, 180 + ((360 / (Level + 1)) * (ComputerShipNumber + 1)));
    CreateShipElement(NewComputerShip);
    UpdateShipElement(NewComputerShip);
  }
  gameObjectId++;
}

function UpdateFramesPerSecond()
{
  FramesPerSecond = FrameCounter;
  FrameCounter = 0;
}
    
function GameLoop()
{
  FrameCounter++;
  
  if(CountdownTimer < 1)
  {
    window.clearInterval(Timer);
    window.clearInterval(GameLoopInterval);
  }
  else
  {
    if (GameOver == true)
    {
      CountdownTimer = CountdownTimer - 1;
    }
    
    SendCommandsToServer();
    UpdateGameObjects();
    CollisionDetection();
    UpdateMap(); // I put this here because updatign the map is based on the new position of the local players ship.
    UpdateGameElements();
    
    tick++;
  }
}

function SendCommandsToServer()
{
  for (var i=1, j=PlayerObjects.length; i<j; i++)
  {
    if (FrameCounter == i+1)
    {
      Think(PlayerObjects[i]);
    }
  }
}

function Think(PlayerObject)
{
  switch (Math.floor(Math.random()*11+1))
  {
    case 1:
      var ThrusterCommand = new CommandObject(PlayerObject.id, 2, PlayerObject.ship, tick+commandDelay);
      IssueCommand(ThrusterCommand);
      break;
    case 3:
    case 4:
    case 11:
      var FireCommand = new CommandObject(PlayerObject.id, 0, PlayerObject.ship, tick+commandDelay);
      IssueCommand(FireCommand);
      break;
    case 6:
    case 7:
      var RotateCounterClockwiseCommand = new CommandObject(PlayerObject.id, 1, PlayerObject.ship, tick+commandDelay);
      IssueCommand(RotateCounterClockwiseCommand);
      break;
    case 8:
    case 9:
      var RotateClockwiseCommand = new CommandObject(PlayerObject.id, 3, PlayerObject.ship, tick+commandDelay);
      IssueCommand(RotateClockwiseCommand);
      break;
    case 2:
    case 5:
    case 10:
      var BrakesCommand = new CommandObject(PlayerObject.id, 4, PlayerObject.ship, tick+commandDelay);
      IssueCommand(BrakesCommand);
      break;
  }
}

function IssueCommand(newCommand)
{
  if (singlePlayer == true)
  {
    httpObject = getHTTPObject();
    if (httpObject != null)
    {
      httpObject.open("GET", "space_battle_server.php?player=" + newCommand.player + "&type=" + newCommand.command + "&target=" + newCommand.target + "&tick=" + newCommand.tick, true);
      httpObject.send(null);
    }
  }
  CommandObjects.push(newCommand);
}

function UpdateGameObjects()
{
  // Can not optimize this loop because the ProcessCommand can
  // add new objects tothe GameObjects array!!!
  for (var i=0; i<GameObjects.length; i++)
  {
    switch (GameObjects[i].Type)
    {
      case 'HumanShip':
      case 'ComputerShip':
        UpdateShipObject(GameObjects[i])
        break;
      case 'Missile':
        UpdateMissileObject(GameObjects[i]);
        break;
      case 'Partical':
        UpdateParticalObject(GameObjects[i]);
        break;
    }
  }
  
  DeleteOldCommands();
}

function UpdateShipObject(ShipObject)
{
  for (var i=0, j=CommandObjects.length; i<j; i++)
  {
    if (CommandObjects[i].target == ShipObject.Id && CommandObjects[i].tick == tick)
    {
      ProcessCommand(CommandObjects[i].command, ShipObject)
    }
  }
  
  if (ShipObject.RotationVelocity > 0)
  {
    if (ShipObject.RotationDirection == 'CounterClockwise')
    {
      ShipObject.Facing = ShipObject.Facing - ShipObject.RotationVelocity * 5 * GameSpeed; 
    }
    else
    {
      ShipObject.Facing = ShipObject.Facing + ShipObject.RotationVelocity * 5 * GameSpeed;
    }
  }

  // This code keeps the Facing Number from 0 to 359. It will break for
  // numbers smaller than -360 and larger than 719
  if (ShipObject.Facing < 0)
  {
    ShipObject.Facing = 360 - ShipObject.Facing * -1;
  }
  else if (ShipObject.Facing > 359)
  {
    ShipObject.Facing = ShipObject.Facing - 360;
  }

  MoveObjectAlongVector(ShipObject);
    
  if (ShipObject.Capacitor < CapacitorMax)
  {
    ShipObject.Capacitor = ShipObject.Capacitor + CapacitorInput * GameSpeed;
  }
  
}

function getHTTPObject()
{
  if (window.ActiveXObject)
  {
    return new ActiveXObject("Microsoft.XMLHTTP");
  }
  else if (window.XMLHttpRequest)
  {
    return new XMLHttpRequest();
  }
  else 
  {
    alert("Your browser does not support AJAX.");
    return null;
  }
}

function KeyPress(evt)
{
  // Spare Bar: Fire!
  if(evt.keyCode == 32)
  {
    evt.preventDefault();
    var newCommand = new CommandObject(0, 0, PlayerObjects[0].ship, tick+commandDelay);
    IssueCommand(newCommand);
  }
  // Rotate CounterClockwise
  else if(evt.keyCode == 37)
  {
    evt.preventDefault();
    var newCommand = new CommandObject(0, 1, PlayerObjects[0].ship, tick+commandDelay);
    IssueCommand(newCommand);
  }
  // Forward Thruster
  else if(evt.keyCode==38)
  {
    evt.preventDefault();
    var newCommand = new CommandObject(0, 2, PlayerObjects[0].ship, tick+commandDelay);
    IssueCommand(newCommand);
  }
  // Rotate Clockwise
  else if(evt.keyCode==39)
  {
    evt.preventDefault();
    var newCommand = new CommandObject(0, 3, PlayerObjects[0].ship, tick+commandDelay);
    IssueCommand(newCommand);
  }
  // Brakes
  else if(evt.keyCode==40)
  {
    evt.preventDefault();
    var newCommand = new CommandObject(0, 4, PlayerObjects[0].ship, tick+commandDelay);
    IssueCommand(newCommand);
  }
  // Center Map on Ship
  else if(evt.keyCode==67)
  {
    evt.preventDefault();
  }
  // Shields
  else if(evt.keyCode==83) 
  {
    evt.preventDefault();
  }

  // Zoom In
  else if(evt.keyCode==107) 
  {
    evt.preventDefault();
    
    if (ZoomLevel > 100)
    {
      ZoomLevel = ZoomLevel - 100;
    }
  }

  // Zoom Out
  else if(evt.keyCode==109) 
  {
    evt.preventDefault();
    ZoomLevel = ZoomLevel + 100;
  }

  // enter - newgame
  else if(evt.keyCode==13 && GameOver == true)
  {
    evt.preventDefault();
    NewGame();
  }
}

function GameObject(Id, Type, LocationX, LocationY, Facing, Heading, Velocity, ShieldStatus, Size, RotationDirection, RotationVelocity, Fuel, Capacitor)
{
  this.Id = Id;
  this.Type = Type;
  this.LocationX = LocationX;
  this.LocationY = LocationY;
  this.Facing = Facing;
  this.Heading = Heading;
  this.Velocity = Velocity;
  this.ShieldStatus = ShieldStatus;
  this.Size = Size;
  this.RotationDirection = RotationDirection;
  this.RotationVelocity = RotationVelocity;
  this.Fuel = Fuel;
  this.Capacitor = Capacitor;
  this.svgElement;
}

function PlayerObject(id, ship)
{
  this.id = id;
  this.ship = ship;
}

function CommandObject(player, command, target, tick)
{
  this.player = player;
  this.command = command;
  this.target = target;
  this.tick = tick;
}

function CreateShipElement(ShipObject)
{
  ShipObject.svgElement = document.createElementNS(svgNS,"path");

  if (ShipObject.Type == 'HumanShip')
  {
    ShipObject.svgElement.setAttributeNS(null, 'stroke', 'green');
  }
  else // Must be a ComputerShip
  {
    ShipObject.svgElement.setAttributeNS(null, 'stroke', 'red');
  }
  
  ShipObject.svgElement.setAttributeNS(null, 'd', 'M -1 -5 L 1 -5 L 2 -4 L 2 -3 L 1 -3 L 1 1 L 3 3 L 3 4 L 2 5 L -2 5 L -3 4 L -3 3 L -1 1 L -1 -3 L -2 -3 L -2 -4 Z');
  ShipObject.svgElement.setAttributeNS(null, 'stroke-linejoin', 'round');
  ShipObject.svgElement.setAttributeNS(null, 'fill', 'black');
  ShipObject.svgElement.setAttribute('transform', 'translate('+ShipObject.LocationX+','+ShipObject.LocationY+') rotate('+ShipObject.Facing+')');

  MapGroupElement.appendChild(ShipObject.svgElement);
}

function UpdateShipElement(ShipObject)
{
  ShipObject.svgElement.setAttribute('transform', 'translate('+ShipObject.LocationX+','+ShipObject.LocationY+') rotate('+ShipObject.Facing+') ');
  
  if (ShipObject.Type == 'HumanShip')
  {
    Capacitor_Current_Energy_Element.firstChild.nodeValue = 'Energy: ' + Math.ceil(ShipObject.Capacitor);
    Debugger_Velocity.firstChild.nodeValue = 'Velocity: ' + Math.round(ShipObject.Velocity);
    FramesPerSecondElement.firstChild.nodeValue = 'FPS: ' + FramesPerSecond;
    Debugger_Heading.firstChild.nodeValue = 'Heading: ' + Math.round(ShipObject.Heading);
    Mission_Summary_Level.firstChild.nodeValue = 'Level: ' + Level;
  }
}

function CreateMissileObject(MissileSource)
{
  var MissileLaunchOffset = 10;

  // Create new GameObject
  MissileObject = new GameObject(gameObjectId, 'Missile', MissileSource.LocationX, MissileSource.LocationY, 0, MissileSource.Heading, MissileSource.Velocity, 'visible', 1, 0, 'None', MissileFuel, 0);
  gameObjectId++;
  
  if (MissileSource.Facing == 0)
  {
    MissileObject.LocationY = MissileObject.LocationY - MissileSource.Size - MissileObject.Size - MissileLaunchOffset;
  }
  else if (MissileSource.Facing == 90)
  {
    MissileObject.LocationX = MissileObject.LocationX + MissileSource.Size + MissileObject.Size + MissileLaunchOffset;
  }
  else if (MissileSource.Facing == 180)
  {
    MissileObject.LocationY = MissileObject.LocationY + MissileSource.Size + MissileObject.Size + MissileLaunchOffset;
  }
  else if (MissileSource.Facing == 270)
  {
    MissileObject.LocationX = MissileObject.LocationX - MissileSource.Size - MissileObject.Size - MissileLaunchOffset;
  }
  else if (MissileSource.Facing < 90)
  {
    MissileObject.LocationX = MissileObject.LocationX + (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.sin(MissileSource.Facing * 0.0174532925));
    MissileObject.LocationY = MissileObject.LocationY - (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.cos(MissileSource.Facing * 0.0174532925));
  }
  else if (MissileSource.Facing < 180)
  {
    MissileObject.LocationX = MissileObject.LocationX + (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.sin((180 - MissileSource.Facing) * 0.0174532925));
    MissileObject.LocationY = MissileObject.LocationY + (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.cos((180 - MissileSource.Facing) * 0.0174532925));
  }
  else if (MissileSource.Facing < 270)
  {
    MissileObject.LocationX = MissileObject.LocationX - (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.sin((MissileSource.Facing - 180) * 0.0174532925));
    MissileObject.LocationY = MissileObject.LocationY + (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.cos((MissileSource.Facing - 180) * 0.0174532925));
  }
  else
  {
    MissileObject.LocationX = MissileObject.LocationX - (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.sin((360 - MissileSource.Facing) * 0.0174532925));
    MissileObject.LocationY = MissileObject.LocationY - (MissileSource.Size + MissileObject.Size + MissileLaunchOffset)*(Math.cos((360 - MissileSource.Facing) * 0.0174532925));
  }

  // The missile starts out with the same velocity as the ship but we then have to factor in it's own initial acceleration. Onces fired, the missile no longer accelerates.
  FindNewVelocity(MissileObject, MissileSource.Facing, MissileVelocity);

  GameObjects.push(MissileObject);

  CreateMissileElement(MissileObject);
}

function CreateMissileElement(MissileObject)
{
  MissileObject.svgElement = document.createElementNS(svgNS,"circle");
  MissileObject.svgElement.setAttributeNS(null, 'cx', MissileObject.LocationX);
  MissileObject.svgElement.setAttributeNS(null, 'cy', MissileObject.LocationY);
  MissileObject.svgElement.setAttributeNS(null, 'r', MissileObject.Size);		
  MissileObject.svgElement.setAttributeNS(null, 'fill', 'yellow');
  MapGroupElement.appendChild(MissileObject.svgElement);
}

function UpdateMissileObject(MissileObject)
{
  MissileObject.Fuel--;
  MoveObjectAlongVector(MissileObject);
}

function UpdateMissileElement(MissileObject)
{
  MissileObject.svgElement.setAttributeNS(null, 'cx', MissileObject.LocationX);
  MissileObject.svgElement.setAttributeNS(null, 'cy', MissileObject.LocationY);
}
  
function CreateParticalObject(ParticalSource)
{
  var NewPartical = new GameObject(gameObjectId, 'Partical', ParticalSource.LocationX, ParticalSource.LocationY, 0, Math.random()*360, Math.random()*10, 'hidden', 1, 'None', 0, 0, Math.random()*10);
  gameObjectId++;
  GameObjects.push(NewPartical);
  CreateParticalElement(NewPartical);
  FindNewVelocity(NewPartical, ParticalSource.Heading, ParticalSource.Velocity); 
}

function CreateParticalElement(ParticalObject)
{
  ParticalObject.svgElement = document.createElementNS(svgNS,"circle");
  ParticalObject.svgElement.setAttributeNS(null, 'cx', ParticalObject.LocationX);	
  ParticalObject.svgElement.setAttributeNS(null, 'cy', ParticalObject.LocationY);	
  ParticalObject.svgElement.setAttributeNS(null, 'r', ParticalObject.Size);		
  ParticalObject.svgElement.setAttributeNS(null, 'fill', 'yellow');
  MapGroupElement.appendChild(ParticalObject.svgElement);
}

function UpdateParticalObject(ParticalObject)
{
  ParticalObject.Capacitor = ParticalObject.Capacitor - 1;

  if (ParticalObject.Capacitor < 1)
  {
    RemoveGameObject(ParticalObject);
  }
  else
  {
    MoveObjectAlongVector(ParticalObject);
  }
}

function UpdateParticalElement(ParticalObject)
{
  ParticalObject.svgElement.setAttributeNS(null, 'cx', ParticalObject.LocationX);	
  ParticalObject.svgElement.setAttributeNS(null, 'cy', ParticalObject.LocationY);
}

function CreateExplosion(SourceGameObject)
{
  for (var i=0; i<ExplosionSize; i++)
  {
    CreateParticalObject(SourceGameObject);
  }
}

function CreateShieldObject(ShieldSource)
{
  var NewShield = new GameObject(gameObjectId, 'Shield', ShieldSource.LocationX, ShieldSource.LocationY, 0, Math.random()*360, Math.random()*10, 'hidden', 1, 'None', 0, 0, Math.random()*10);
  gameObjectId++;
  GameObjects.push(NewPartical);
  CreateParticalElement(NewPartical);
  FindNewVelocity(NewPartical, ParticalSource.Heading, ParticalSource.Velocity); 
}

function CreateParticalElement(ParticalObject)
{
  ParticalObject.svgElement = document.createElementNS(svgNS,"circle");
  ParticalObject.svgElement.setAttributeNS(null, 'cx', ParticalObject.LocationX);	
  ParticalObject.svgElement.setAttributeNS(null, 'cy', ParticalObject.LocationY);	
  ParticalObject.svgElement.setAttributeNS(null, 'r', ParticalObject.Size);		
  ParticalObject.svgElement.setAttributeNS(null, 'fill', 'yellow');
  MapGroupElement.appendChild(ParticalObject.svgElement);
}

function UpdateParticalObject(ParticalObject)
{
  ParticalObject.Capacitor = ParticalObject.Capacitor - 1;

  if (ParticalObject.Capacitor < 1)
  {
    RemoveGameObject(ParticalObject);
  }
  else
  {
    MoveObjectAlongVector(ParticalObject);
  }
}

function UpdateParticalElement(ParticalObject)
{
  ParticalObject.svgElement.setAttributeNS(null, 'cx', ParticalObject.LocationX);	
  ParticalObject.svgElement.setAttributeNS(null, 'cy', ParticalObject.LocationY);
}

function CreateExplosion(SourceGameObject)
{
  for (var i=0; i<ExplosionSize; i++)
  {
    CreateParticalObject(SourceGameObject);
  }
}

function renderScope(parentNode)
{
  // Group
  var ScopeGroupElement = document.createElementNS(svgNS,"g");
  x = componentOffset;
  y = AvailablePixels * .1 + componentOffset;
  ScopeGroupElement.setAttribute('transform', 'translate(' + x + ',' + y +')');
  parentNode.appendChild(ScopeGroupElement);
  
    // Background
    var ScopeElement = document.createElementNS(svgNS,"rect");
    ScopeElement.setAttributeNS(null, "x", 0);	
    ScopeElement.setAttributeNS(null, "y", 0);		
    ScopeElement.setAttributeNS(null, "rx", roundingConstant);
    ScopeElement.setAttributeNS(null, "ry", roundingConstant);
    ScopeElement.setAttributeNS(null, "height", AvailablePixels * .5 - componentOffset);
    ScopeElement.setAttributeNS(null, "width", AvailablePixels - componentOffset * 2);
    ScopeElement.setAttributeNS(null, "stroke", "gray");
    ScopeElement.setAttributeNS(null, "stroke-width", "2px");
    ScopeElement.setAttributeNS(null, "fill", "dimgray");
    ScopeGroupElement.appendChild(ScopeElement);

    // Viewport
    var Map_Viewport = document.createElementNS(svgNS,"svg");
    Map_Viewport.setAttributeNS(null, "x", componentOffset);	
    Map_Viewport.setAttributeNS(null, "y", componentOffset);		
    Map_Viewport.setAttributeNS(null, "rx", roundingConstant);
    Map_Viewport.setAttributeNS(null, "ry", roundingConstant);
    Map_Viewport.setAttributeNS(null, "height", AvailablePixels * .5 - componentOffset * 3);
    Map_Viewport.setAttributeNS(null, "width", AvailablePixels - componentOffset * 4);
    ScopeGroupElement.appendChild(Map_Viewport);
  
      // scopeScreen
      var scopeScreen = document.createElementNS(svgNS,"rect");
      scopeScreen.setAttributeNS(null, "x", 0);	
      scopeScreen.setAttributeNS(null, "y", 0);		
      scopeScreen.setAttributeNS(null, "rx", roundingConstant);
      scopeScreen.setAttributeNS(null, "ry", roundingConstant);
      scopeScreen.setAttributeNS(null, "height", AvailablePixels * .5 - componentOffset * 3);
      scopeScreen.setAttributeNS(null, "width", AvailablePixels - componentOffset * 4);
      scopeScreen.setAttributeNS(null, "fill", "black");
      Map_Viewport.appendChild(scopeScreen);
      
      // Map
      var centerMap = document.createElementNS(svgNS,"g");
      x = ((AvailablePixels - componentOffset) * 0.5);
      y = ((AvailablePixels - componentOffset) * 0.25);
      centerMap.setAttribute('transform', 'translate('+ x +','+ y +') scale(' + CurrentScale + ')');
      Map_Viewport.appendChild(centerMap);

      // Map
      MapGroupElement = document.createElementNS(svgNS,"g");
      MapGroupElement.setAttributeNS(null, 'cursor', 'crosshair');
      centerMap.appendChild(MapGroupElement);
}

function renderRibbon(parentNode)
{
  // Group
  var ribbonGroup = document.createElementNS(svgNS,"g");
  x = componentOffset;
  y = componentOffset;
  ribbonGroup.setAttribute('transform', 'translate(' + x + ',' + y + ')');
  parentNode.appendChild(ribbonGroup);

    // Background
    var ribbonBackground = document.createElementNS(svgNS,"rect");
    ribbonBackground.setAttributeNS(null, "x", 0);	
    ribbonBackground.setAttributeNS(null, "y", 0);		
    ribbonBackground.setAttributeNS(null, "rx", roundingConstant);
    ribbonBackground.setAttributeNS(null, "ry", roundingConstant);
    ribbonBackground.setAttributeNS(null, "height", AvailablePixels * .1 - componentOffset);
    ribbonBackground.setAttributeNS(null, "width", AvailablePixels - componentOffset * 2);
    ribbonBackground.setAttributeNS(null, "stroke", "gray");
    ribbonBackground.setAttributeNS(null, "stroke-width", "2px");
    ribbonBackground.setAttributeNS(null, "fill", "dimgray");
    ribbonGroup.appendChild(ribbonBackground);
}

function renderMissionSummary(parentNode)
{
  // Mission_Summary_Group
  var Mission_Summary_Group = document.createElementNS(svgNS,"g");
  x = componentOffset;
  y = (AvailablePixels * .5 - componentOffset * 2 ) + (AvailablePixels * .1) + (componentOffset * 3);
  Mission_Summary_Group.setAttribute('transform', 'translate(' + x + ',' + y + ')');
  parentNode.appendChild(Mission_Summary_Group);

    // Mission_Summary_Control
    var Mission_Summary_Control = document.createElementNS(svgNS,"rect");
    Mission_Summary_Control.setAttributeNS(null, "x", 0);	
    Mission_Summary_Control.setAttributeNS(null, "y", 0);		
    Mission_Summary_Control.setAttributeNS(null, "rx", roundingConstant);
    Mission_Summary_Control.setAttributeNS(null, "ry", roundingConstant);
    Mission_Summary_Control.setAttributeNS(null, "height", AvailablePixels * .1 - componentOffset * 2);
    Mission_Summary_Control.setAttributeNS(null, "width", AvailablePixels * .5 - componentOffset * 2);
    Mission_Summary_Control.setAttributeNS(null, "stroke", "gray");
    Mission_Summary_Control.setAttributeNS(null, "stroke-width", "2px");
    Mission_Summary_Control.setAttributeNS(null, "fill", "dimgray");
    Mission_Summary_Group.appendChild(Mission_Summary_Control);

    var Mission_Summary_Name_Plate = document.createElementNS(svgNS, "text");
    Mission_Summary_Name_Plate.setAttributeNS(null, "x", 20);
    Mission_Summary_Name_Plate.setAttributeNS(null, "y", 20);
    Mission_Summary_Name_Plate.setAttributeNS(null, "font-size", 20);
    Mission_Summary_Name_Plate.setAttributeNS(null, "fill", 'black');
    Mission_Summary_Name_Plate.appendChild(document.createTextNode("MISSION SUMMARY"));
    Mission_Summary_Group.appendChild(Mission_Summary_Name_Plate);

    Mission_Summary_Level = document.createElementNS(svgNS, "text");
    Mission_Summary_Level.setAttributeNS(null, "x", 20);
    Mission_Summary_Level.setAttributeNS(null, "y", 50);
    Mission_Summary_Level.setAttributeNS(null, "font-size", 15);
    Mission_Summary_Level.setAttributeNS(null, "fill", 'black');
    Mission_Summary_Level.appendChild(document.createTextNode("Level: 1"));
    Mission_Summary_Group.appendChild(Mission_Summary_Level);
}

function renderCapacitor(parentNode)
{
  // Render the CapacitorGroup
  var CapacitorGroupElement = document.createElementNS(svgNS,"g");
  x = componentOffset;
  y = (AvailablePixels * .5 - componentOffset * 2 ) + (AvailablePixels * .1) + (AvailablePixels * .1) + (componentOffset * 2);
  CapacitorGroupElement.setAttribute('transform', 'translate(' + x + ',' + y + ')');
  parentNode.appendChild(CapacitorGroupElement);

  // Render the Capacitor
  var CapacitorElement = document.createElementNS(svgNS,"rect");
  CapacitorElement.setAttributeNS(null, "x", 0);	
  CapacitorElement.setAttributeNS(null, "y", 0);		
  CapacitorElement.setAttributeNS(null, "rx", roundingConstant);
  CapacitorElement.setAttributeNS(null, "ry", roundingConstant);
  CapacitorElement.setAttributeNS(null, "height", AvailablePixels * .10 - componentOffset * 2);
  CapacitorElement.setAttributeNS(null, "width", AvailablePixels * .5 - componentOffset * 2);
  CapacitorElement.setAttributeNS(null, "stroke", "gray");
  CapacitorElement.setAttributeNS(null, "stroke-width", "2px");
  CapacitorElement.setAttributeNS(null, "fill", "dimgray");
  CapacitorGroupElement.appendChild(CapacitorElement);

  var Capacitor_Name_Plate = document.createElementNS(svgNS, "text");
  Capacitor_Name_Plate.setAttributeNS(null, "x", 20);
  Capacitor_Name_Plate.setAttributeNS(null, "y", 20);
  Capacitor_Name_Plate.setAttributeNS(null, "font-size", 20);
  Capacitor_Name_Plate.setAttributeNS(null, "fill", 'black');
  Capacitor_Name_Plate.appendChild(document.createTextNode("PRIMARY CAPACITOR"));
  CapacitorGroupElement.appendChild(Capacitor_Name_Plate);

  Capacitor_Current_Energy_Element = document.createElementNS(svgNS, "text");
  Capacitor_Current_Energy_Element.setAttributeNS(null, "x", 20);
  Capacitor_Current_Energy_Element.setAttributeNS(null, "y", 50);
  Capacitor_Current_Energy_Element.setAttributeNS(null, "font-size", 15);
  Capacitor_Current_Energy_Element.setAttributeNS(null, "fill", 'black');
  Capacitor_Current_Energy_Element.appendChild(document.createTextNode("Energy: 10"));
  CapacitorGroupElement.appendChild(Capacitor_Current_Energy_Element);
}

function renderDebugger(parentNode)
{
  // Render the DebugerGroup
  var DebugerGroupElement = document.createElementNS(svgNS,"g");
  x = componentOffset;
  y = (AvailablePixels * .5 - componentOffset * 2 ) + (AvailablePixels * .3) + (componentOffset * 1);
  DebugerGroupElement.setAttribute('transform', 'translate(' + x + ',' + y + ')');
  parentNode.appendChild(DebugerGroupElement);
  
  // Render the Debuger
  var DebugerElement = document.createElementNS(svgNS,"rect");
  DebugerElement.setAttributeNS(null, "x", 0);	
  DebugerElement.setAttributeNS(null, "y", 0);		
  DebugerElement.setAttributeNS(null, "rx", roundingConstant);
  DebugerElement.setAttributeNS(null, "ry", roundingConstant);
  DebugerElement.setAttributeNS(null, "height", AvailablePixels * .22 - componentOffset * 2);
  DebugerElement.setAttributeNS(null, "width", AvailablePixels * .5 - componentOffset * 2);
  DebugerElement.setAttributeNS(null, "stroke", "gray");
  DebugerElement.setAttributeNS(null, "stroke-width", "2px");
  DebugerElement.setAttributeNS(null, "fill", "dimgray");
  DebugerGroupElement.appendChild(DebugerElement);

  var Debugger_Name_Plate = document.createElementNS(svgNS, "text");
  Debugger_Name_Plate.setAttributeNS(null, "x", 20);
  Debugger_Name_Plate.setAttributeNS(null, "y", 20);
  Debugger_Name_Plate.setAttributeNS(null, "font-size", 20);
  Debugger_Name_Plate.setAttributeNS(null, "fill", 'black');
  Debugger_Name_Plate.appendChild(document.createTextNode("SHIP DEBUGGER"));
  DebugerGroupElement.appendChild(Debugger_Name_Plate);

  Debugger_Velocity = document.createElementNS(svgNS, "text");
  Debugger_Velocity.setAttributeNS(null, "x", 20);
  Debugger_Velocity.setAttributeNS(null, "y", 50);
  Debugger_Velocity.setAttributeNS(null, "font-size", 15);
  Debugger_Velocity.setAttributeNS(null, "fill", 'black');
  Debugger_Velocity.appendChild(document.createTextNode("Velocity: 0"));
  DebugerGroupElement.appendChild(Debugger_Velocity);

  FramesPerSecondElement = document.createElementNS(svgNS, "text");
  FramesPerSecondElement.setAttributeNS(null, "x", 20);
  FramesPerSecondElement.setAttributeNS(null, "y", 90);
  FramesPerSecondElement.setAttributeNS(null, "font-size", 15);
  FramesPerSecondElement.setAttributeNS(null, "fill", 'black');
  FramesPerSecondElement.appendChild(document.createTextNode("FPS: 0"));
  DebugerGroupElement.appendChild(FramesPerSecondElement);

  Debugger_Heading = document.createElementNS(svgNS, "text");
  Debugger_Heading.setAttributeNS(null, "x", 20);
  Debugger_Heading.setAttributeNS(null, "y", 70);
  Debugger_Heading.setAttributeNS(null, "font-size", 15);
  Debugger_Heading.setAttributeNS(null, "fill", 'black');
  Debugger_Heading.appendChild(document.createTextNode("Heading: 0"));
  DebugerGroupElement.appendChild(Debugger_Heading);
}

function renderAutoPilot(parentNode)
{
  var autoPilot = document.createElementNS(svgNS,"g");
  x = (AvailablePixels * .5 - componentOffset * 2 ) + (componentOffset * 2);
  y = (AvailablePixels * .5 - componentOffset * 2 ) + (AvailablePixels * .1) + (componentOffset * 3);
  autoPilot.setAttribute('transform', 'translate(' + x + ',' + y + ')');
  parentNode.appendChild(autoPilot);

    var autoPilotBackground = document.createElementNS(svgNS,"rect");
    autoPilotBackground.setAttributeNS(null, "x", 0);	
    autoPilotBackground.setAttributeNS(null, "y", 0);		
    autoPilotBackground.setAttributeNS(null, "rx", roundingConstant);
    autoPilotBackground.setAttributeNS(null, "ry", roundingConstant);
    autoPilotBackground.setAttributeNS(null, "height", AvailablePixels * .4 - componentOffset * 2);
    autoPilotBackground.setAttributeNS(null, "width", AvailablePixels * .5 - componentOffset * 2);
    autoPilotBackground.setAttributeNS(null, "stroke", "gray");
    autoPilotBackground.setAttributeNS(null, "stroke-width", "2px");
    autoPilotBackground.setAttributeNS(null, "fill", "dimgray");
    autoPilot.appendChild(autoPilotBackground);
}

function renderFireButton(parentNode)
{
  var fireButton = document.createElementNS(svgNS,"g");
  x = (AvailablePixels * .5 - componentOffset * 2 ) + (componentOffset * 3);
  y = (AvailablePixels * .5 - componentOffset * 2 ) + (AvailablePixels * .1) + (componentOffset * 4);
  fireButton.setAttribute('transform', 'translate(' + x + ',' + y + ')');
  parentNode.appendChild(fireButton);

    fireButtonBackground = document.createElementNS(svgNS,"rect");
    fireButtonBackground.setAttributeNS(null, "onmouseover", "fireButtonOnMouseOver()");
    fireButtonBackground.setAttributeNS(null, "onmouseout",  "fireButtonOnMouseOut()");
    fireButtonBackground.setAttributeNS(null, "onmousedown", "fireButtonOnMouseDown()");
    fireButtonBackground.setAttributeNS(null, "onmouseup",   "fireButtonOnMouseUp()"); 
    // fireButtonBackground.setAttributeNS(null, "onclick",     "fireButtonOnClick()");    
    fireButtonBackground.setAttributeNS(null, "x", 0);	
    fireButtonBackground.setAttributeNS(null, "y", 0);		
    fireButtonBackground.setAttributeNS(null, "rx", roundingConstant);
    fireButtonBackground.setAttributeNS(null, "ry", roundingConstant);
    fireButtonBackground.setAttributeNS(null, "height", AvailablePixels * .1 - componentOffset * 2);
    fireButtonBackground.setAttributeNS(null, "width",  AvailablePixels * .1 - componentOffset * 2);
    fireButtonBackground.setAttributeNS(null, "stroke", "gray");
    fireButtonBackground.setAttributeNS(null, "stroke-width", "2px");
    fireButtonBackground.setAttributeNS(null, "fill", "dimgray");
    fireButton.appendChild(fireButtonBackground);
}

function fireButtonOnMouseOver()
{
  fireButtonBackground.setAttributeNS(null, "stroke", "yellow");
}

function fireButtonOnMouseOut()
{
  fireButtonBackground.setAttributeNS(null, "stroke", "gray");
  fireButtonBackground.setAttributeNS(null, "fill", "dimgray");
}

function fireButtonOnMouseDown()
{
  fireButtonBackground.setAttributeNS(null, "fill", "gray");
  var newCommand = new CommandObject(0, 0, PlayerObjects[0].ship, tick+commandDelay);
  IssueCommand(newCommand);
}

function fireButtonOnMouseUp()
{
  fireButtonBackground.setAttributeNS(null, "fill", "dimgray");
}

function fireButtonOnClick()
{
  fireButtonBackground.setAttributeNS(null, "fill", "gray");
  var newCommand = new CommandObject(0, 0, PlayerObjects[0].ship, tick+commandDelay);
  IssueCommand(newCommand);
}

function DeleteOldCommands()
{
  numberOfCommandsToDelete = 0;
  
  for (var i=0, j=CommandObjects.length; i<j; i++)
  {
    if (CommandObjects[i].tick > tick)
    {
      numberOfCommandsToDelete = i;
      break;
    }
  }
  
  CommandObjects.splice(0, numberOfCommandsToDelete)
}

function UpdateGameElements()
{
  for (var i=0, j=GameObjects.length; i<j; i++)
  {
    switch (GameObjects[i].Type)
    {
      case 'ComputerShip':
      case 'HumanShip':
        UpdateShipElement(GameObjects[i])
        break;
      case 'Missile':
        UpdateMissileElement(GameObjects[i]);
        break;
      case 'Partical':
        UpdateParticalElement(GameObjects[i]);
        break;
    }
  }
  
  
}

function ProcessCommand(Command, GameObject)
{
  switch (Command)
  {
    case 0:
      if (GameObject.Capacitor > 2)
      {
        CreateMissileObject(GameObject);
        GameObject.Capacitor = GameObject.Capacitor - 3;
      }
      break;
    case 3:
      if (GameObject.Capacitor > 0)
      {
        if (GameObject.RotationDirection == 'Clockwise')
        {
          GameObject.RotationVelocity = GameObject.RotationVelocity + 1;
        }
        else if (GameObject.RotationDirection == 'None')
        {
          GameObject.RotationVelocity = GameObject.RotationVelocity + 1;
          GameObject.RotationDirection = 'Clockwise';
        }
        else // GameObject.RotationDirection == 'CounterClockwise'
        {
          GameObject.RotationVelocity = GameObject.RotationVelocity - 1;
       
          if (GameObject.RotationVelocity == 0)
          {
            GameObject.RotationDirection = 'None';
          }
        }
        GameObject.Capacitor = GameObject.Capacitor - 1;
      }
      break;
    case 1:
      if (GameObject.Capacitor > 0)
      {
        if (GameObject.RotationDirection == 'CounterClockwise')
        {
          GameObject.RotationVelocity = GameObject.RotationVelocity + 1;
        }
        else if (GameObject.RotationDirection == 'None')
        {
          GameObject.RotationVelocity = GameObject.RotationVelocity + 1;
          GameObject.RotationDirection = 'CounterClockwise';
        }
        else
        {
          GameObject.RotationVelocity = GameObject.RotationVelocity - 1;
          
          if (GameObject.RotationVelocity == 0)
          {
            GameObject.RotationDirection = 'None';
          }
        }
        GameObject.Capacitor = GameObject.Capacitor - 1;
      }
      break;
    case 2:
      if (GameObject.Capacitor > 0)
      {
        FindNewVelocity(GameObject, GameObject.Facing, 1)
        GameObject.Capacitor = GameObject.Capacitor - 1;
      }
      break;
    case 4:
      if (GameObject.Velocity > 0 && GameObject.Capacitor > 0)
      {
        GameObject.Velocity = GameObject.Velocity - 1;
        GameObject.Capacitor = GameObject.Capacitor - 1;
      }
      
      if (GameObject.RotationVelocity > 0 && GameObject.Capacitor > 0)
      {
        GameObject.RotationVelocity = GameObject.RotationVelocity - 1;
          
        if (GameObject.RotationVelocity == 0)
        {
          GameObject.RotationDirection = 'None';
        }

        GameObject.Capacitor = GameObject.Capacitor - 1;
      }
      break;
  }

  // This should really get checked by each indivifual command
  // but I'm feeling lzy tonight...
  if (GameObject.Velocity < 0)
  {
    GameObject.Velocity = 0;
  }
}

function BoundryChecking()
{
  for (var i = 0; i < GameObjects.length; i++)
  {
    // Check to see if GameObject has flown past the border. I do this by measuring the distance
    // from the Game Object to the center of the screen and making sure the distance is smaller
    // than the radius of the screen.
    if (!(GameObjects[i].LocationX * GameObjects[i].LocationX + GameObjects[i].LocationY * GameObjects[i].LocationY < MapRadius * MapRadius))
    {
      DeadObjects.push(GameObjects[i]);
    }
  }
  RemoveDeadObjects()
}
     
function CollisionDetection()
{
  // Run Colision Detection for each GameObject
  for (var i = 0; i < GameObjects.length; i++)
  {
    // Ignore Particle objects when looking for collisions
    if (GameObjects[i].Type != 'Partical')
    {
      // Find this distance between this and every other object in the game and check to see if it
      // is smaller than the combined radius of the two objects.
      for (var j = 0; j < GameObjects.length; j++)
      {
        // Don't let objects colide with themselves or particals!
        if (GameObjects[i] != GameObjects[j] && GameObjects[j].Type != 'Partical')
        {
          if (Math.sqrt((GameObjects[i].LocationX - GameObjects[j].LocationX) * (GameObjects[i].LocationX - GameObjects[j].LocationX) + (GameObjects[i].LocationY - GameObjects[j].LocationY) * (GameObjects[i].LocationY - GameObjects[j].LocationY)) < (GameObjects[i].Size + GameObjects[j].Size))
          {
            // This object has collided with something so we get to blow it up!!!
            CreateExplosion(GameObjects[i]);

            // I created this array of objects to remove because removing objects from
            // an array while you are still iterating over the same array is generaly
            // a bad thing!
            DeadObjects.push(GameObjects[i]);
            
            // No use blowing this up twice!
            break;
          }
        }
      }
    }
  }
  
  RemoveDeadObjects();
  
  for (var k = 0; k < GameObjects.length; k++)
  {
    if ((GameObjects[k].Type == "Missile") && (GameObjects[k].Fuel < 1))
    {
      DeadObjects.push(GameObjects[k]);
    }
  }
  
  RemoveDeadObjects();
}

function RemoveDeadObjects()
{
  for (var i=0, j=DeadObjects.length; i<j; i++)
  {
    RemoveGameObject(DeadObjects[i]);
  }
  
  DeadObjects.length = 0;
}
    
function RemoveGameObject(GameObject)
{
  SvgElementToDelete = GameObject.svgElement;
  SvgElementToDelete.parentNode.removeChild(SvgElementToDelete);
  
  var i = 0;

  switch (GameObject.Type)
  {
    case 'HumanShip':
      GameOver = true;
      break;
    case 'ComputerShip':
      EnemyCount = EnemyCount - 1;
      if (EnemyCount < 1)
      {
        GameOver = true;
      }
      break;
  }
  
  for (var j = 0; j < GameObjects.length; j++)
  {
    if (GameObjects[j] == GameObject)
    {
      GameObjects.splice(i, 1);
    }
    else
    {
      i++;
    }
  }
}

function FindNewVelocity(GameObject, NewHeading, NewVelocity)
{
  NewXaxisComponent = GetXaxisComponent(GameObject.Heading, GameObject.Velocity) + GetXaxisComponent(NewHeading, NewVelocity);
  NewYaxisComponent = GetYaxisComponent(GameObject.Heading, GameObject.Velocity) + GetYaxisComponent(NewHeading, NewVelocity);

  if (NewXaxisComponent == 0 && NewYaxisComponent == 0)
  {
    GameObject.Heading = 0;
    GameObject.Velocity = 0;
  }
  else if (NewXaxisComponent == 0 && NewYaxisComponent < 0)
  {
    GameObject.Heading = 0;
    GameObject.Velocity = Math.abs(NewYaxisComponent);
  }
  else if (NewXaxisComponent > 0 && NewYaxisComponent == 0)
  {
    GameObject.Heading = 90;
    GameObject.Velocity = Math.abs(NewXaxisComponent);
  }
  else if (NewXaxisComponent == 0 && NewYaxisComponent > 0)
  {
    GameObject.Heading = 180;
    GameObject.Velocity = Math.abs(NewYaxisComponent);
  }
  else if (NewXaxisComponent < 0 && NewYaxisComponent == 0)
  {
    GameObject.Heading = 270;
    GameObject.Velocity = Math.abs(NewXaxisComponent);
  }
  else if (NewXaxisComponent < 0 && NewYaxisComponent < 0)
  {
    GameObject.Velocity = Math.sqrt(NewXaxisComponent * NewXaxisComponent + NewYaxisComponent * NewYaxisComponent);
    GameObject.Heading = 360 - Math.atan(NewXaxisComponent / NewYaxisComponent) / 0.0174532925;
  }
  else if (NewXaxisComponent < 0 && NewYaxisComponent > 0)
  {
    GameObject.Velocity = Math.sqrt(NewXaxisComponent * NewXaxisComponent + NewYaxisComponent * NewYaxisComponent);
    GameObject.Heading = (Math.atan(Math.abs(NewXaxisComponent) / NewYaxisComponent) / 0.0174532925) - 180;
  }
  else if (NewXaxisComponent > 0 && NewYaxisComponent < 0)
  {
    GameObject.Velocity = Math.sqrt(NewXaxisComponent * NewXaxisComponent + NewYaxisComponent * NewYaxisComponent);
    GameObject.Heading = Math.atan(NewXaxisComponent / Math.abs(NewYaxisComponent)) / 0.0174532925;
  }
  else if (NewXaxisComponent > 0 && NewYaxisComponent > 0)
  {
    GameObject.Velocity = Math.sqrt(NewXaxisComponent * NewXaxisComponent + NewYaxisComponent * NewYaxisComponent);
    GameObject.Heading = 180 - Math.atan(NewXaxisComponent / NewYaxisComponent) / 0.0174532925;
  }
}

function GetXaxisComponent(Direction, Magnitude)
{
  var XaxisComponent = 0;

  if (Direction == 0)
  {
    XaxisComponent = 0;
  }
  else if (Direction == 90)
  {
     XaxisComponent = Magnitude;
  }
  else if (Direction == 180)
  {
    XaxisComponent = 0;
  }
  else if (Direction == 270)
  {
    XaxisComponent = -1 * Magnitude;
  }
  else if (Direction < 90)
  {
    XaxisComponent = Magnitude * (Math.sin(Direction * 0.0174532925));
  }
  else if (Direction < 180)
  {
    XaxisComponent = Magnitude * (Math.sin((180 - Direction) * 0.0174532925));
  }
  else if (Direction < 270)
  {
    XaxisComponent = -1 * Magnitude * (Math.sin((Direction - 180) * 0.0174532925));
  }
  else
  {
    XaxisComponent = -1 * Magnitude * (Math.sin((360 - Direction) * 0.0174532925));
  }

  return XaxisComponent;
}

function GetYaxisComponent(Direction, Magnitude)
{
  var YaxisComponent = 0;

  if (Direction == 0)
  {
    YaxisComponent = -1 * Magnitude;
  }
  else if (Direction == 90)
  {
    YaxisComponent = 0;
  }
  else if (Direction == 180)
  {
    YaxisComponent = Magnitude;
  }
  else if (Direction == 270)
  {
    YaxisComponent = 0;
  }
  else if (Direction < 90)
  {
    YaxisComponent =  -1 * Magnitude * (Math.cos(Direction * 0.0174532925));
  }
  else if (Direction < 180)
  {
    YaxisComponent =  Magnitude * (Math.cos((180 - Direction) * 0.0174532925));
  }
  else if (Direction < 270)
  {
    YaxisComponent =  Magnitude * (Math.cos((Direction - 180) * 0.0174532925));
  }
  else
  {
    YaxisComponent =  -1 * Magnitude * (Math.cos((360 - Direction) * 0.0174532925));
  }

  return YaxisComponent;
}
    
function MoveObjectAlongVector(GameObject) 
{
  if (GameObject.Heading == 0)
  {
    GameObject.LocationY = GameObject.LocationY - GameObject.Velocity * GameSpeed;
  }
  else if (GameObject.Heading == 90)
  {
    GameObject.LocationX = GameObject.LocationX + GameObject.Velocity * GameSpeed;
  }
  else if (GameObject.Heading == 180)
  {
    GameObject.LocationY = GameObject.LocationY + GameObject.Velocity * GameSpeed;
  }
  else if (GameObject.Heading == 270)
  {
    GameObject.LocationX = GameObject.LocationX - GameObject.Velocity * GameSpeed;
  }
  else if (GameObject.Heading < 90)
  {
    GameObject.LocationX = GameObject.LocationX + GameObject.Velocity * GameSpeed * (Math.sin(GameObject.Heading * 0.0174532925));
    GameObject.LocationY = GameObject.LocationY - GameObject.Velocity * GameSpeed * (Math.cos(GameObject.Heading * 0.0174532925));
  }
  else if (GameObject.Heading < 180)
  {
    GameObject.LocationX = GameObject.LocationX + GameObject.Velocity * GameSpeed * (Math.sin((180 - GameObject.Heading) * 0.0174532925));
    GameObject.LocationY = GameObject.LocationY + GameObject.Velocity * GameSpeed * (Math.cos((180 - GameObject.Heading) * 0.0174532925));
  }
  else if (GameObject.Heading < 270)
  {
    GameObject.LocationX = GameObject.LocationX - GameObject.Velocity * GameSpeed * (Math.sin((GameObject.Heading - 180) * 0.0174532925));
    GameObject.LocationY = GameObject.LocationY + GameObject.Velocity * GameSpeed * (Math.cos((GameObject.Heading - 180) * 0.0174532925));
  }
  else
  {
    GameObject.LocationX = GameObject.LocationX - GameObject.Velocity * GameSpeed * (Math.sin((360 - GameObject.Heading) * 0.0174532925));
    GameObject.LocationY = GameObject.LocationY - GameObject.Velocity * GameSpeed * (Math.cos((360 - GameObject.Heading) * 0.0174532925));
  }
}

function SetStartingPosition(GameObject, Angle)
{
  if (Angle == 0)
  {
    GameObject.LocationX = 0;
    GameObject.LocationY = StartingDistanceFromCenter * -1;
  }
  else if (Angle == 90)
  {
    GameObject.LocationX = StartingDistanceFromCenter;
    GameObject.LocationY = 0;
  }
  else if (Angle == 180)
  {
    GameObject.LocationX = 0;
    GameObject.LocationY = StartingDistanceFromCenter;
  }
  else if (Angle == 270)
  {
    GameObject.LocationX = StartingDistanceFromCenter * -1;
    GameObject.LocationY = 0;
  }
  else if (Angle < 90)
  {
    GameObject.LocationX = StartingDistanceFromCenter * Math.sin(Angle * 0.0174532925);
    GameObject.LocationY = StartingDistanceFromCenter * Math.cos(Angle * 0.0174532925) * -1;
  }
  else if (Angle < 180)
  {
    GameObject.LocationX = StartingDistanceFromCenter * Math.sin((180 - Angle) * 0.0174532925);
    GameObject.LocationY = StartingDistanceFromCenter * Math.cos((180 - Angle) * 0.0174532925);
  }
  else if (Angle < 270)
  {
    GameObject.LocationX = StartingDistanceFromCenter * Math.sin((Angle - 180) * 0.0174532925) * -1;
    GameObject.LocationY = StartingDistanceFromCenter * Math.cos((Angle - 180) * 0.0174532925);
  }
  else // 360
  {
    GameObject.LocationX = StartingDistanceFromCenter * Math.sin((360 - Angle) * 0.0174532925) * -1;
    GameObject.LocationY = StartingDistanceFromCenter * Math.cos((360 - Angle) * 0.0174532925) * -1;
  }

  GameObject.Facing = Angle + 180;
}
    
function UpdateMap()
{
  newCurrentScale = AvailablePixels / ZoomLevel;
  x = HumanShip.LocationX * -1;
  y = HumanShip.LocationY * -1;
  MapGroupElement.setAttribute('transform', 'scale(' + newCurrentScale + ') translate('+ x +','+ y +')');
}

function handle(delta)
{
  if (delta < 0)
    ZoomLevel = ZoomLevel + 50;
  else
    if (ZoomLevel > 50)
    {
      ZoomLevel = ZoomLevel - 50;
    }
}

function wheel(event)
{
  var delta = 0;
  
  // For IE.
  if (!event)
  {
    event = window.event;
  }
  
  if (event.wheelDelta)
  { /* IE/Opera. */
    delta = event.wheelDelta/120;
    /** In Opera 9, delta differs in sign as compared to IE.
     */
    if (window.opera)
    {
      delta = -delta;
      }
  }
  else if (event.detail) 
  { /** Mozilla case. */
    /** In Mozilla, sign of delta is different than in IE.
     * Also, delta is multiple of 3.
     */
    delta = -event.detail/3;
  }
  /** If delta is nonzero, handle it.
   * Basically, delta is now positive if wheel was scrolled up,
   * and negative, if wheel was scrolled down.
   */
  if (delta)
  {
    handle(delta);
  }
  /** Prevent default actions caused by mouse wheel.
   * That might be ugly, but we handle scrolls somehow
   * anyway, so don't bother here..
   */
  if (event.preventDefault)
  {
    event.preventDefault();
  }
	event.returnValue = false;
}

    ]]></script>
  </head>
  <body>
    <svg id="Canvas" onload="Init()" width="100%" height="100%" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg"></svg>
  </body>
</html>